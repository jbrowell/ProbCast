% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contCDF.R
\name{contCDF}
\alias{contCDF}
\title{Continuous CDF from \code{MultiQR} object}
\usage{
contCDF(
  quantiles,
  kfold = NULL,
  inverse = F,
  method = list(name = "spline", splinemethod = "monoH.FC"),
  tails = list(method = "extrapolate", L = 0, U = 1)
)
}
\arguments{
\item{quantiles}{A single-row \code{MultiQR} object.}

\item{method}{Method of interpolation. See details.}

\item{tails}{Definition of tails. See details.}

\item{kfolds}{Fold/test label corresponding to \code{quantiles}.}
}
\value{
A cumulative densift function of the type produced by \code{splinefun} and
\code{approxfun}.
}
\description{
This function generats a smooth, continuous CDF a given row of a \code{MultiQR}
object. Interpolation if performed between quantiles and a range of tail models
are available for extrapolating beyond beyond the last estimated upper and lower
quantile.
}
\details{
Interpolation between quantiles may be linear of via smooth splines:

Linear interpolation: \code{method="linear"} linear interpolation
between quantiles.

Spline interpolation: \code{method=list(name=spline,splinemethod=monoH.FC)}, where spline method is
passed to \code{splinefun}. \code{splinefun=monoH.FC} is recommended to gaurantee monotoincally
increasing function.


Several options are available for specifying distribution tails beyond
the final upper and lower quantiles:

Linear extrapolation: \code{tails=list(method="extrapolate",L,U)} value set to \code{L} and \code {U}
for probability levels 0 and 1, respectively. If \code{method="extrapolate_dtail1"} then
tails are exrapolated to the 50th quantile plus (minus) \code{U} (\code{L}).

Exponential tails: \code{tails=list(method="exponential",thicknessPL,thicknessPR,ntailpoints=5)}
the user will either supply user defined thickness parameters for the tail
via \code{thicknessPL} and \code{thicknessPR}. The number
of tail quantiles to be estimated is set by \code{ntailpoints}.
Alternatively \code{tails=list(method="exponential",thickparamFunc)} where \code{thickparamFunc}
is a function that takes the q50 as an input and returns the thickness parameter.
Alternatively (not recommmended) \code{tails=list(method="exponential",preds,nbins,targetvar)} a symetrical tail
thickness can be defined data-driven by specifying: number of bins \code{nbins}, a MQR
object \code{preds}, and the target variable, \code{targetvar}.

Dynamic exponential tails: \code{tails=list(method="dyn_exponential",...)} ...

Generalised Pareto Distribution: \code{tails="gpd", scale_r,shape_r,
scale_l,shape_l,tail_qs=seq(0.1,2,by=0.1)} with left (_l) and right (_r) scale and shape parameters.
Quantiles are calculated at points defined by the upper (lower) quantile plus (minus)
\code{tail_qs}.
}
\author{
Jethro Browell, \email{jethro.browell@strath.ac.uk}; Ciaran Gilbert, \email{ciaran.gilbert@strath.ac.uk}
}
